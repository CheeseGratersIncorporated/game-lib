import { ObjectId } from 'mongodb';
import clientPromise from '@/lib/mongodb';
import {cards} from '@/lib/poetry_for_neanderthals/cards';

export async function POST(req: Request, context: { params: { id: string } }) {
  const {id:gameId} = await context.params;
  //const { playerNick, team } = await req.json();

  const client = await clientPromise;
  const db = client.db('game-libDB');
  const games = db.collection('game-lib');


  const game= await games.findOne({ _id: new ObjectId(gameId) });
  const updateData:any={};
    let error=-1;
    for(let key in game!.teams){
        if(game!.teams[key].players.length<2){
            error=0;
            //throw new Error("not enough nerds in each team");
            return Response.json({error});
        }
        
    }
     updateData.$set= { 
        [`turnOrder`]: generateTurnOrder(game as any),
        ['shuffledDeck']: randomPermutation(cards.length),
        currentDeckCard:0,
        currentTurn:0,
        cardHistory:[],
        points:Array(game!.teamCount).fill(0),
        

     };
  

  const result = await games.findOneAndUpdate(
      { _id: new ObjectId(gameId) },
      updateData,
      
    { returnDocument: 'after' }
    );
  

  return Response.json({ updatedGame: result,error });
}


//This was generated by chat gpt uwu
function generateTurnOrder(game: {
  players: string[],
  teams: Record<string, { players: string[] }>,
  teamCount: number
}): string[] {
  const teamPools: Record<string, string[]> = {};

  // Make a deep copy of teams to avoid mutating original game object
  for (const [teamName, team] of Object.entries(game.teams)) {
    teamPools[teamName] = [...team.players];
  }

  const turnOrder: string[] = [];
  let lastTeam = '';

  while (turnOrder.length < game.players.length) {
    // Step 1: Filter out the last used team
    const availableTeams = Object.entries(teamPools)
      .filter(([teamName, players]) => teamName !== lastTeam && players.length > 0);

    if (availableTeams.length === 0) {
      // If only lastTeam has players left, allow it
      const fallbackTeams = Object.entries(teamPools).filter(([, players]) => players.length > 0);
      if (fallbackTeams.length === 0) break; // done
      const [teamName, players] = fallbackTeams[0];
      const playerIndex = Math.floor(Math.random() * players.length);
      const player = players.splice(playerIndex, 1)[0];
      turnOrder.push(player);
      lastTeam = teamName;
      continue;
    }

    // Step 2: Find the max size among remaining teams
    const maxSize = Math.max(...availableTeams.map(([, players]) => players.length));
    const largestTeams = availableTeams.filter(([, players]) => players.length === maxSize);

    // Step 3: Pick a random team from the largest
    const [chosenTeamName, chosenTeamPlayers] = largestTeams[Math.floor(Math.random() * largestTeams.length)];

    // Step 4: Pick a random player from the team
    const playerIndex = Math.floor(Math.random() * chosenTeamPlayers.length);
    const player = chosenTeamPlayers.splice(playerIndex, 1)[0];

    // Step 5: Add to turn order
    turnOrder.push(player);
    lastTeam = chosenTeamName;
  }

  return turnOrder;
}
function randomPermutation(n:number) {
  const arr = Array.from({ length: n }, (_, i) => i);
  
  // Fisher-Yates shuffle
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }

  return arr;
}